#!/usr/bin/python
# Copyright (C) 2011 Red Hat, Inc.
# Copyright (C) 2011 Jan Smejda
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
import os
import pyfaf
import subprocess
import logging

# Command line argument processing
cmdline_parser = pyfaf.argparse.ArgumentParser(description="Generate optimized backtraces from local cache attachments.")
cmdline_parser.add_argument("--only-missing", action="store_true", default=False, help="Skip already existing optimized backtraces")
cmdline_parser.add_argument("--overwrite", action="store_true", default=False, help="Overwrite existing optimized backtraces")
cmdline_args = cmdline_parser.parse_args()

db = pyfaf.cache.Database()
db.execute("SELECT id, bug_id FROM rhbz_attachment WHERE file_name = 'backtrace'")

i = 0
rows = db.fetchall()
for row in rows:
    i += 1
    path = pyfaf.run.cache_get_path("rhbz-optimized-backtrace", row[1], failure_allowed=True)
    if not path is None and os.path.isfile(path) and cmdline_args.only_missing:
        logging.debug("[{0}/{1}] Skipping existing {2}".format(i, len(rows), row[0]))
        continue

    logging.info("[{0}/{1}] Processing {2}".format(i, len(rows), row[0]))
    attachment = pyfaf.run.cache_get("rhbz-attachment", row[0], failure_allowed=True)
    if not attachment:
        logging.debug("Unable to load attachment from cache, skipping")
        continue

    # Parse the backtrace
    btparser_proc = subprocess.Popen(['btparser', '-i', '-o'],
                                     stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = btparser_proc.communicate(attachment.contents)
    if btparser_proc.returncode != 0:
        logging.info("btparser exited with {0}.".format(btparser_proc.returncode))
        if stdout:
            logging.debug("STDOUT:\n{0}".format(stdout))
        if stderr:
            logging.debug("STDERR:\n{0}".format(stderr))
        continue

    # Write optimized backtrace into cache
    pyfaf.run.cache_add_text(stdout, row[1], "rhbz-optimized-backtrace", overwrite=cmdline_args.overwrite)

db.close()
