#!/usr/bin/python
# -*- encoding: utf-8 -*-
# Test code quality
import unittest2 as unittest
import subprocess
import os.path
import re

class PylintTest(unittest.TestCase):

    def setUp(self):
        # For a list of available message ids, see pylint source code:
        # http://hg.logilab.org/pylint/
        #
        # C0103 - Invalid name ...
        #  Reports "id" as an invalid name.
        # C0301 - Line too long
        #  Sometimes it's better to have a longer line
        pylint_proc = subprocess.Popen(["pylint", "./pyfaf", "--output-format=parseable", "--include-ids=yes",
                                        "--disable=C0103,C0301"],
                                       cwd=os.path.abspath(".."),
                                       stdout=subprocess.PIPE,
                                       stderr=subprocess.PIPE)
        stdout, stderr = pylint_proc.communicate()
        #self.assertEqual(pylint_proc.returncode, 0)

        # Parse the output.
        self.issues = []
        for line in stdout.splitlines():
            match = re.match("^(pyfaf/[a-zA-Z0-9\\._/]+):(\\d+): \\[([A-Z])(\d+) ?([^\\]]*)\\] (.*)$", line)
            if match is None:
                continue
            self.issues.append(match.group(1, 2, 3, 4, 5, 6))

    def test_noErrors(self):
        # We fail on fatal errors and errors.
        for path, line, type, number, context, message in self.issues:
            self.assertNotEqual(type, "E", msg="Error {0}{1} found in {2}:{3}: {4} {5}".format(type, number, path, line, context, message))
            self.assertNotEqual(type, "F", msg="Fatal error {0}{1} found in {2}:{3}: {4} {5}".format(type, number, path, line, context, message))

    def test_limitNumberOfIssues(self):
        refactor = 0
        convention = 0
        warning = 0
        for path, line, type, number, context, message in self.issues:
            if type == "R":
                refactor += 1
            elif type == "C":
                convention += 1
            elif type == "W":
                warning += 1
            elif type == "I":
                # Ingore informational messages, such as:
                # pyfaf/cache/__init__.py:455 Locally disabling E1121.
                pass
            elif type == "E":
                # Ignore errors, they are catched by another test.
                pass
            else:
                self.fail("Unknown pylint issue type {0}: {1}:{2}: {3}.".format(type, path, line, message))

        REFACTOR_LIMIT = 500 # do not care much about this one
        self.assertTrue(refactor <= REFACTOR_LIMIT, "Too many ({0}) refactor issues found by pylint. Run `pylint ./pyfaf` from the toplevel directory and fix at least {1} of them.".format(refactor, refactor - REFACTOR_LIMIT))

        CONVENTION_LIMIT = 600
        self.assertTrue(convention <= CONVENTION_LIMIT, "Too many ({0}) code convention issues found by pylint. Run `pylint ./pyfaf` from the toplevel directory and fix at least {1} of them.".format(convention, convention - CONVENTION_LIMIT))

        WARNING_LIMIT = 800
        self.assertTrue(warning <= WARNING_LIMIT, "Too many ({0}) warnings found by pylint. Run `pylint ./pyfaf` from the toplevel directory and fix at least {1} of them.".format(warning, warning - WARNING_LIMIT))

if __name__ == '__main__':
    unittest.main()
