#!/usr/bin/python
# -*- encoding: utf-8 -*-
# Test local cache implementation, including the
# command line client faf-cache.
import unittest
import tempfile
import shutil
import subprocess
import os
import sys
import datetime
import random
import string
import signal
sys.path.insert(0, os.path.abspath(".."))
os.environ["PATH"] = "{0}:{1}".format(os.path.abspath(".."), os.environ["PATH"])
import pyfaf

class TestCaseSQLite(unittest.TestCase):
    USER_10_TEXT = u"""Id: 10
Email: test
CanLogin: True
Name: testuser
RealName: Test User ěščřžýáíé
"""
    def _db_connect(self):
        return pyfaf.cache.Database(db_type="sqlite3", sqlite3_cache_dir=self.cache_dir)

    def _cache_popen(self, args, stdin=None):
        args = ["faf-cache", "--cache-dir", self.cache_dir, "--db-type", "sqlite3"] + args
        return subprocess.Popen(args, stdout=subprocess.PIPE, stdin=stdin, stderr=subprocess.PIPE)

    def _create_user_10(self):
        # Test that add works with right parameters
        proc = self._cache_popen(args=["add", "rhbz-user", str(10)], stdin=subprocess.PIPE)
        stdout, stderr = proc.communicate(self.USER_10_TEXT.encode("utf-8"))
        self.assertEqual(stdout, "")
        self.assertEqual(stderr, "")
        self.assertEqual(proc.returncode, 0)

    def _user_path(self, user_id):
        return os.path.join(self.cache_dir, "rhbz-user", str(user_id))

    def setUp(self):
        self.cache_dir = tempfile.mkdtemp(prefix="faf-cache-test")

    def tearDown(self):
        shutil.rmtree(self.cache_dir)

class TestCaseMySql(TestCaseSQLite):
    def _db_connect(self, mysql_db=None):
        if mysql_db is None:
            mysql_db = self.db_name

        return pyfaf.cache.Database(db_type="mysql", mysql_host="localhost",
                                    mysql_socket=self.mysql_socket,
                                    mysql_user="root", mysql_passwd="", mysql_db=mysql_db)

    def _cache_popen(self, args, stdin=None):
        args = ["faf-cache", "--cache-dir", self.cache_dir,
                "--db-type", "mysql",
                "--mysql-host", "localhost",
                "--mysql-socket", self.mysql_socket,
                "--mysql-user", "root",
                "--mysql-passwd", "",
                "--mysql-db", self.db_name] + args
        return subprocess.Popen(args, stdout=subprocess.PIPE, stdin=stdin, stderr=subprocess.PIPE)

    def setUp(self):
        TestCaseSQLite.setUp(self)

        self.db_name = "faf"

        # temp socket name
        self.mysql_dir = tempfile.mkdtemp(prefix="faf-cache-test-mysql")
        self.mysql_socket = os.path.join(self.mysql_dir, "socket")
        self.mysql_pid = os.path.join(self.mysql_dir, "pid")
        self.mysql_log = os.path.join(self.mysql_dir, "log")

        args = ["mysql_install_db", "--datadir={0}".format(self.mysql_dir)]
        subprocess.check_call(args, stdout=subprocess.PIPE)

        args = ["mysqld_safe",
                "--datadir={0}".format(self.mysql_dir),
                "--socket={0}".format(self.mysql_socket),
                "--pid-file={0}".format(self.mysql_pid),
                "--log-error={0}".format(self.mysql_log),
                "--skip-networking"]
        self.mysql_proc = subprocess.Popen(args, stdout=subprocess.PIPE)

        # wait for server to initialize
        while not os.path.isfile(self.mysql_pid):
            pass

        with self._db_connect(mysql_db="") as db:
            db.execute("CREATE DATABASE {0}".format(self.db_name))

    def tearDown(self):
        TestCaseSQLite.tearDown(self)
        with self._db_connect(mysql_db="") as db:
            db.execute("DROP DATABASE {0}".format(self.db_name))

        with open(self.mysql_pid, "r") as f:
            pid = int(f.read())

        os.kill(pid, signal.SIGTERM)
        self.mysql_proc.terminate()
        self.mysql_proc.wait()
        shutil.rmtree(self.mysql_dir)

# Test command-line functionality
class CommandLineInterface:
    def test_add(self):
        # Valid add of one user.
        self._create_user_10()

        # Test cache file, which is encoded in UTF-8
        with open(self._user_path(10), 'r') as f:
            self.assertEqual(unicode(f.read(), "utf-8"), self.USER_10_TEXT)

        # Test cache database
        with self._db_connect() as db:
            db.execute("SELECT * FROM rhbz_user")
            rows = db.fetchall()
            self.assertEqual(len(rows), 1)
            self.assertEqual(rows[0], (10, u"test", 1, u"testuser", u"Test User ěščřžýáíé"))

    def test_show(self):
        # Test that show works with right parameters
        self._create_user_10()
        proc = self._cache_popen(args=["show", "rhbz-user", "10"])
        stdout, stderr = proc.communicate()
        # Standard output comes in UTF-8 encoding.
        self.assertEqual(stdout, self.USER_10_TEXT.encode("utf-8"))
        self.assertEqual(stderr, "")
        self.assertEqual(proc.returncode, 0)

    def test_list(self):
        # Test list with no item
        proc = self._cache_popen(args=["list", "rhbz-user"])
        stdout, stderr = proc.communicate()
        self.assertEqual(stdout, "")
        self.assertEqual(stderr, "")
        self.assertEqual(proc.returncode, 0)

        # Test list with one item
        self._create_user_10()
        proc = self._cache_popen(args=["list", "rhbz-user"])
        stdout, stderr = proc.communicate()
        self.assertEqual(proc.returncode, 0)
        self.assertEqual(stdout, "10\n")
        self.assertEqual(stderr, "")

        # Test list with %mtime formatting
        proc = self._cache_popen(args=["list", "rhbz-user", "--format", "%id %mtime"])
        stdout, stderr = proc.communicate()
        self.assertEqual(proc.returncode, 0)
        self.assertEqual(stdout, "10 {0}\n".format(os.stat(self._user_path(10)).st_mtime))
        self.assertEqual(stderr, "")

    def test_verify(self):
        # Test verify of a correct user
        self._create_user_10()
        proc = self._cache_popen(args=["verify"])
        stdout, stderr = proc.communicate()
        self.assertEqual(stdout, "")
        self.assertEqual(stderr, "")
        self.assertEqual(proc.returncode, 0)

    def test_stats(self):
        # Full stats with single rhbz-user.
        self._create_user_10()
        proc = self._cache_popen(args=["stats"])
        stdout, stderr = proc.communicate()
        self.assertIn("rhbz-user: 1 entries, {0} bytes total (max {0} bytes, min {0} bytes)".format(
                len(self.USER_10_TEXT.encode("utf-8"))), stdout)
        self.assertEqual(stderr, "")
        self.assertEqual(proc.returncode, 0)

    def test_remove(self):
        # Remove an user.
        self._create_user_10()
        proc = self._cache_popen(args=["remove", "--target", "rhbz-user", "--id", "10"])
        stdout, stderr = proc.communicate()
        self.assertEqual(stdout, "")
        self.assertEqual(stderr, "")
        self.assertEqual(proc.returncode, 0)

        # Test database
        with self._db_connect() as db:
            db.execute("SELECT * FROM rhbz_user")
            rows = db.fetchall()
            self.assertEqual(len(rows), 0)

class CommandLineInterfaceSQLite(CommandLineInterface, TestCaseSQLite):
    pass

class CommandLineInterfaceMySql(CommandLineInterface, TestCaseMySql):
    pass

class FunctionInterface:
    def setUp(self):
        pyfaf.run.target_from_name.db = self._db_connect()
        pyfaf.run.target_from_name.cache_dir = self.cache_dir

    def tearDown(self):
        pyfaf.run.target_from_name.db.close()
        delattr(pyfaf.run.target_from_name, 'target_list')
        delattr(pyfaf.run.target_from_name, 'cache_dir')
        delattr(pyfaf.run.target_from_name, 'db')

    def test_list(self):
        res = pyfaf.run.cache_list_id("rhbz-user")
        self.assertEqual(res, [])

        self._create_user_10()

        res = pyfaf.run.cache_list_id("rhbz-user")
        self.assertEqual(res, [10])

        (entries, times) = pyfaf.run.cache_list_id_mtime("rhbz-user")
        self.assertEqual(entries, [10])

        self.assertEqual(times.keys(), [10])
        filedatetime = datetime.datetime.fromtimestamp(os.stat(self._user_path(10)).st_mtime)
        # one of the microsecond values is probably rounded
        self.assertEqual(times[10].replace(microsecond=0), filedatetime.replace(microsecond=0))

    def test_get(self):
        res = pyfaf.run.cache_get("rhbz-user", 10, failure_allowed=True)
        self.assertIsNone(res)

        self._create_user_10()

        res = pyfaf.run.cache_get("rhbz-user", 10)
        self.assertEqual(res.id, 10)
        self.assertEqual(res.real_name, u"Test User ěščřžýáíé")

    def test_get_path(self):
        res = pyfaf.run.cache_get_path("rhbz-user", 10, failure_allowed=True)
        self.assertIsNone(res)
        self._create_user_10()
        res = pyfaf.run.cache_get_path("rhbz-user", 10)
        self.assertEqual(res, self._user_path(10))

        # Test binary as well.
        res = pyfaf.run.cache_get_path("fedora-koji-rpm-data", 10, failure_allowed=True)
        self.assertIsNone(res)
        os.mkdir(os.path.join(self.cache_dir, "fedora-koji-rpm-data"))
        dest_path = os.path.join(self.cache_dir, "fedora-koji-rpm-data", str(10))
        shutil.copyfile("perl-Test-Portability-Files-0.05-13.fc16.src.rpm", dest_path)
        res = pyfaf.run.cache_get_path("fedora-koji-rpm-data", 10, failure_allowed=True)
        self.assertEqual(res, dest_path)

    def test_add(self):
        res = pyfaf.run.cache_get("rhbz-user", 10, failure_allowed=True)
        self.assertIsNone(res)
        pyfaf.run.cache_add_text(self.USER_10_TEXT, 10, "rhbz-user", False)
        res = pyfaf.run.cache_get("rhbz-user", 10)
        self.assertEqual(res.id, 10)
        self.assertEqual(res.real_name, u"Test User ěščřžýáíé")

        user = pyfaf.cache.rhbz_user.RhbzUser()
        user.id = 22
        user.email = "test"
        user.can_login = False
        user.name = u"ššŠŠ"
        user.real_name = u"žžŽŽ"
        pyfaf.run.cache_add(user, overwrite=False)

        res = pyfaf.run.cache_get("rhbz-user", 22)
        self.assertEqual(res.id, 22)
        self.assertEqual(res.name, u"ššŠŠ")
        self.assertEqual(res.real_name, u"žžŽŽ")

    def test_remove(self):
        pyfaf.run.cache_remove("rhbz-user", 10, failure_allowed=True)
        self._create_user_10()
        res = pyfaf.run.cache_get("rhbz-user", 10)
        self.assertEqual(res.id, 10)
        pyfaf.run.cache_remove("rhbz-user", 10, failure_allowed=True)
        res = pyfaf.run.cache_get("rhbz-user", 10, failure_allowed=True)
        self.assertIsNone(res)

class FunctionInterfaceSQLite(FunctionInterface, TestCaseSQLite):
    def setUp(self):
        TestCaseSQLite.setUp(self)
        FunctionInterface.setUp(self)

    def tearDown(self):
        TestCaseSQLite.tearDown(self)
        FunctionInterface.tearDown(self)

class FunctionInterfaceMySql(FunctionInterface, TestCaseMySql):
    def setUp(self):
        TestCaseMySql.setUp(self)
        FunctionInterface.setUp(self)

    def tearDown(self):
        TestCaseMySql.tearDown(self)
        FunctionInterface.tearDown(self)

# Test database functionality
class Database:
    def _create_bug(self, bug_id=738387):
        proc = self._cache_popen(args=["add", "rhbz-bug", str(bug_id)], stdin=subprocess.PIPE)
        stdout, stderr = proc.communicate(u"""
Id: {0}
Summary: ipw2200 driver deadlocks with itself trying to take rtnl_mutex (ěščřžýáíé)
Status: CLOSED
Resolution: ERRATA
CreationTime: 2011-09-14T17:06:00.000000
LastChangeTime: 2011-09-24T04:37:25.000000
Product: Fedora
ProductVersion: 16
Component: kernel
Whiteboard: AcceptedBlocker
CreatorId: 5319
Comments: 4017008, 4017016, 4017270, 4017404
Attachments: 523202, 523203, 523255, 523524
Cc: 273090, 281569, 182415, 211762, 176318
History:
- UserId: 163460
  Time: 2011-09-15T15:38:38.000000
  Field: cc
  Added: afdasf@redhat.com
- UserId: 140047
  Time: 2011-09-15T23:03:43.500000
  Field: cc
  Added: sdfsdf@sdfsdf.com
""".format(bug_id).encode("utf-8"))
        self.assertEqual(stdout, "")
        self.assertEqual(stderr, "")
        self.assertEqual(proc.returncode, 0)

    def test_table_create(self):
        self._create_bug(bug_id=738387)

        # Test that the table has been created.
        with self._db_connect() as db:
            tables = db.fetch_table_list()
            self.assertIn(u"rhbz_bug", tables)
            self.assertIn(u"rhbz_bug_comments", tables)
            self.assertIn(u"rhbz_bug_attachments", tables)
            self.assertIn(u"rhbz_bug_cc", tables)
            self.assertIn(u"rhbz_bug_history", tables)
            #self.assertIn(u"rhbz_bug_id", "rhbz_bug"), rows3)
            #self.assertIn(u"rhbz_bug_component", "rhbz_bug"), rows3)

            info = db.fetch_table_info("rhbz_bug")
            self.assertEqual(len(info), 12)
            self.assertEqual(info[0], [u"id", u"INTEGER"])
            self.assertEqual(info[1], [u"summary", u"TEXT"])
            self.assertEqual(info[2], [u"status", u"TEXT"])
            self.assertEqual(info[3], [u"resolution", u"TEXT"])
            self.assertEqual(info[4], [u"resolution_dup_id", u"INTEGER"])
            self.assertEqual(info[5], [u"creation_time", u"TIMESTAMP"])
            self.assertEqual(info[6], [u"last_change_time", u"TIMESTAMP"])
            self.assertEqual(info[7], [u"product", u"TEXT"])
            self.assertEqual(info[8], [u"product_version", u"TEXT"])
            self.assertEqual(info[9], [u"component", u"TEXT"])
            self.assertEqual(info[10], [u"whiteboard", u"TEXT"])
            self.assertEqual(info[11], [u"creator_id", u"INTEGER"])

            info = db.fetch_table_info("rhbz_bug_history")
            self.assertEqual(len(info), 6)
            self.assertEqual(info[0], [u"rhbz_bug_id", u"INTEGER"])
            self.assertEqual(info[1], [u"user_id", u"INTEGER"])

            info = db.fetch_table_info("rhbz_bug_attachments")
            self.assertEqual(len(info), 2)
            self.assertEqual(info[0], [u"rhbz_bug_id", u"INTEGER"])
            self.assertEqual(info[1], [u"value", u"INTEGER"])

    def test_table_data(self):
        with self._db_connect() as db:
            self._create_bug(bug_id=738387)
            db.commit()
            db.execute("SELECT * FROM rhbz_bug")
            rows = db.fetchall()
            self.assertEqual(len(rows), 1)
            row = rows[0]
            self.assertEqual(len(row), 12)
            self.assertEqual(row[0], 738387) # id
            self.assertEqual(row[1], u"ipw2200 driver deadlocks with itself trying to take rtnl_mutex (ěščřžýáíé)") # summary
            self.assertEqual(row[2], u"CLOSED") # status
            self.assertEqual(row[3], u"ERRATA") # resolution
            self.assertEqual(row[4], None) # resolution_dup_id
            self.assertEqual(row[5], datetime.datetime(2011, 9, 14, 17, 6)) # creation_time
            self.assertEqual(row[6], datetime.datetime(2011, 9, 24, 4, 37, 25)) # last_change_time
            self.assertEqual(row[7], u"Fedora") # product
            self.assertEqual(row[8], u"16") # product_version
            self.assertEqual(row[9], u"kernel") # component
            self.assertEqual(row[10], u"AcceptedBlocker") # whiteboard
            self.assertEqual(row[11], 5319) # creatir_id

            db.execute("SELECT * FROM rhbz_bug_comments")
            rows = db.fetchall()
            self.assertEqual(len(rows), 4)
            # bug_id, value
            self.assertEqual(rows[0], (738387, 4017008))
            self.assertEqual(rows[1], (738387, 4017016))
            self.assertEqual(rows[2], (738387, 4017270))
            self.assertEqual(rows[3], (738387, 4017404))

            db.execute("SELECT * FROM rhbz_bug_history")
            rows = db.fetchall()
            self.assertEqual(len(rows), 2)
            self.assertEqual(len(rows[0]), 6)
            self.assertEqual(rows[0][0], 738387) # bug_id
            self.assertEqual(rows[0][1], 163460) # user_id
            self.assertEqual(rows[0][2], datetime.datetime(2011, 9, 15, 15, 38, 38)) # time
            self.assertEqual(rows[0][3], u"cc") # field
            self.assertEqual(rows[0][4], u"afdasf@redhat.com") # added
            self.assertEqual(rows[0][5], None) # removed

            self.assertEqual(rows[1][0], 738387) # bug_id
            self.assertEqual(rows[1][1], 140047) # user_id
            # time - MySQL does not store the microseconds part, SQLite does.
            self.assertTrue(rows[1][2] == datetime.datetime(2011, 9, 15, 23, 3, 43, 500000) or
                            rows[1][2] == datetime.datetime(2011, 9, 15, 23, 3, 43))
            self.assertEqual(rows[1][3], u"cc") # field
            self.assertEqual(rows[1][4], u"sdfsdf@sdfsdf.com") # added
            self.assertEqual(rows[1][5], None) # removed

            # Also test user data as it contains a boolean entry
            self._create_user_10()
            db.commit()
            db.execute("SELECT * FROM rhbz_user")
            rows = db.fetchall()
            self.assertEqual(len(rows), 1)
            # id, email, can_login, name, real_name
            self.assertEqual(rows[0], (10, u"test", 1, u"testuser", u"Test User ěščřžýáíé"))

    def test_table_data_remove(self):
        with self._db_connect() as db:
            # Test basic removal of single user.
            self._create_user_10()
            db.commit()

            db.execute("SELECT * FROM rhbz_user")
            self.assertEqual(len(db.fetchall()), 1)

            proc = self._cache_popen(args=["remove", "--target", "rhbz-user", "--id", "10"])
            stdout, stderr = proc.communicate()
            self.assertEqual(stdout, "")
            self.assertEqual(stderr, "")
            self.assertEqual(proc.returncode, 0)
            db.commit()

            db.execute("SELECT * FROM rhbz_user")
            self.assertEqual(len(db.fetchall()), 0)

            # Test removal of a bug with subtables.  TODO: Insert two
            # bugs, remove one, check consistency of the remaining bug,
            # remove it, check that tables are empty.
            self._create_bug(bug_id=738387)
            self._create_bug(bug_id=738388)
            proc = self._cache_popen(args=["remove", "--target", "rhbz-bug", "--id", "738387"])
            stdout, stderr = proc.communicate()
            self.assertEqual(stdout, "")
            self.assertEqual(stderr, "")
            self.assertEqual(proc.returncode, 0)
            db.commit()

            db.execute("SELECT * FROM rhbz_bug")
            rows = db.fetchall()
            self.assertEqual(len(rows), 1)
            self.assertEqual(rows[0][0], 738388)
            db.execute("SELECT * FROM rhbz_bug_comments")
            rows = db.fetchall()
            self.assertEqual(len(rows), 4)
            [self.assertEqual(row[0], 738388) for row in rows]
            db.execute("SELECT * FROM rhbz_bug_attachments")
            self.assertEqual(len(db.fetchall()), 4)
            db.execute("SELECT * FROM rhbz_bug_cc")
            self.assertEqual(len(db.fetchall()), 5)
            db.execute("SELECT * FROM rhbz_bug_history")
            rows = db.fetchall()
            self.assertEqual(len(rows), 2)
            [self.assertEqual(row[0], 738388) for row in rows]

            proc = self._cache_popen(args=["remove", "--target", "rhbz-bug", "--id", "738388"])
            stdout, stderr = proc.communicate()
            self.assertEqual(stdout, "")
            self.assertEqual(stderr, "")
            self.assertEqual(proc.returncode, 0)
            db.commit()

            db.execute("SELECT * FROM rhbz_bug;")
            self.assertEqual(len(db.fetchall()), 0)
            db.execute("SELECT * FROM rhbz_bug_comments")
            self.assertEqual(len(db.fetchall()), 0)
            db.execute("SELECT * FROM rhbz_bug_attachments")
            self.assertEqual(len(db.fetchall()), 0)
            db.execute("SELECT * FROM rhbz_bug_cc")
            self.assertEqual(len(db.fetchall()), 0)
            db.execute("SELECT * FROM rhbz_bug_history")
            self.assertEqual(len(db.fetchall()), 0)

class DatabaseSQLite(Database, TestCaseSQLite):
    pass

class DatabaseMySql(Database, TestCaseMySql):
    pass

if __name__ == '__main__':
    unittest.main()
