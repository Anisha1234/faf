#!/usr/bin/python
# Copyright (C) 2011 Red Hat, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# funfin = Function Fingerprint
import pyfaf
import logging
import itertools

# Command line argument processing
cmdline_parser = pyfaf.argparse.ArgumentParser(description="Report on funfin.")
cmdline_args = cmdline_parser.parse_args()


# Load database and bugs
logging.debug("Connecting to DB.")
db = pyfaf.cache.Database()

# Find multiple builds of same component.
db.execute("SELECT id FROM fedora_koji_build_funfin_report")
report_ids = {i[0] for i in db.fetchall()}

clusters = []
logging.info("Preparing clusters.")
while any(report_ids):
    db.execute("SELECT name FROM fedora_koji_build WHERE id = ?", [report_ids.pop()])
    name = db.fetchall()[0][0]
    query = """SELECT r.id FROM fedora_koji_build_funfin_report r
                   JOIN fedora_koji_build b ON r.id = b.id
                   WHERE b.name=?"""
    db.execute(query, [name])
    cluster = {i[0] for i in db.fetchall()}
    if len(cluster) == 0:
        logging.error("Failed to find {0} in fedora_koji_build table.".format(name))
        exit(1)
    report_ids -= cluster
    clusters.append(cluster)

class BinaryDupsEvaluation:
    def __init__(self):
        # Which RPM this is.
        self.rpm_id = None
        # Which binary (abs path) is this.
        self.binary = None
        # List of (symbolA, symbolB, symbolC) duplicates from the binary.
        self.duplicates = []
        # Number of all symbols in that binary.
        self.symbol_count = 0

class CrossBinaryEvaluation:
    def __init__(self):
        self.rpm_id_a = None
        self.rpm_id_b = None
        # Which binary (abs path) is this.
        self.binary = None
        # Number of symbols that matched between the binaries.
        self.matched_count = 0
        # Number of symbols present in just one of the binaries.
        self.not_found_count = 0
        # Names of symbols that differ between the binaries.
        self.unmatched = []

def get_fingerprint(fingerprint_parts, report_function):
    return "".join([report_function.__dict__[part] for part in fingerprint_parts])

class Fingerprint:
    def __init__(self, parts):
        # Names of metrics, such as "fp_library_function_calls".
        self.parts = parts
        self.dupsEvaluations = []
        self.crossEvaluations = []

    def add_binary_dups_evaluation(self, report):
        for rpm in report.rpms:
            for binary in rpm.binaries:
                e = BinaryDupsEvaluation()
                e.rpm_id = rpm.id
                e.binary = binary.id
                e.symbol_count = len(binary.functions)
                d = {}
                for fun in binary.functions:
                    fingerprint = get_fingerprint(self.parts, fun)
                    if fingerprint in d:
                        #logging.debug("Duplicate fingerprint: {0}".format(fingerprint))
                        d[fingerprint].append(fun)
                    else:
                        #logging.debug("New fingerprint: {0}".format(fingerprint))
                        d[fingerprint] = [fun]

                for fingerprint, funs in d.items():
                    if len(funs) > 1:
                        #logging.debug("APPENDING TO DUPLICATES: {0}".format([fun.symbol for fun in funs]))
                        e.duplicates.append([fun.symbol for fun in funs])
                self.dupsEvaluations.append(e)

    def add_cross_binary_evaluation(self, report1, report2):
        for rpm1 in report1.rpms:
            for binary1 in rpm1.binaries:
                for rpm2 in report2.rpms:
                    for binary2 in rpm2.binaries:
                        if binary1.id != binary2.id:
                            continue

                        e = CrossBinaryEvaluation()
                        e.rpm_id_a = rpm1.id
                        e.rpm_id_b = rpm2.id
                        e.binary = binary1.id
                        e.not_found_count = len({f.symbol for f in binary1.functions} ^ {f.symbol for f in binary2.functions})

                        for fun1 in binary1.functions:
                            for fun2 in binary2.functions:
                                if fun1.symbol != fun2.symbol:
                                    continue

                                f1 = get_fingerprint(self.parts, fun1)
                                f2 = get_fingerprint(self.parts, fun2)
                                if f1 == f2:
                                    e.matched_count += 1
                                else:
                                    e.unmatched.append(fun1.symbol)
                                break

                        self.crossEvaluations.append(e)

    def update_success_rates(self):
        """
        1 = 100% success, no duplicates
        """
        dup_allsyms = 0
        dup_dupsyms = 0
        for e in self.dupsEvaluations:
            dup_allsyms += e.symbol_count
            dup_dupsyms += reduce(lambda a,d: a + len(d), e.duplicates, 0)

        self.success_rate = 0
        self.success_rate_count = 0

        if dup_allsyms > 0:
            self.dup_success_rate = 1.0 - (dup_dupsyms / float(dup_allsyms))
            self.success_rate_count += 1
            self.success_rate += self.dup_success_rate
        else:
            self.dup_success_rate = 0

        cross_allsyms = 0
        cross_unmatchedsyms = 0
        for e in self.crossEvaluations:
            cross_allsyms += e.matched_count + len(e.unmatched)
            cross_unmatchedsyms += len(e.unmatched)
        if cross_allsyms > 0:
            self.cross_success_rate = 1.0 - (cross_unmatchedsyms/float(cross_allsyms))
            self.success_rate_count += 1
            self.success_rate += self.cross_success_rate
        else:
            self.cross_success_rate = 0

        if self.success_rate_count > 0:
            self.success_rate /= self.success_rate_count

fingerprints = []
fingerprints.append(Fingerprint(["fp_library_function_calls"]))
fingerprints.append(Fingerprint(["fp_transitive_lib_calls"]))
fingerprints.append(Fingerprint(["fp_equality_jump_presence"]))
fingerprints.append(Fingerprint(["fp_unsigned_comparison_jump_presence"]))
fingerprints.append(Fingerprint(["fp_signed_comparison_jump_presence"]))
fingerprints.append(Fingerprint(["fp_andor_presence"]))
fingerprints.append(Fingerprint(["fp_shift_presence"]))
fingerprints.append(Fingerprint(["fp_simple_recursion_presence"]))
fingerprints.append(Fingerprint(["fp_unconditional_local_jump_presence"]))
fingerprints.append(Fingerprint(["fp_internal_calls"]))

def print_report():
    for f in fingerprints:
        f.update_success_rates()

    top = sorted(fingerprints, key=lambda x: x.success_rate, reverse=True)
    top_index = 0
    print("-- Best fingerprints")
    print("---------------------------")
    print("count name                    duplicate success    cross success")
    for f in top:
        top_index += 1
        print("{0}. {1}\t\t\t\t{2:.2f}%\t{3:.2f}%".format(top_index, ", ".join(f.parts), f.dup_success_rate * 100, f.cross_success_rate * 100))


index = 0
for cluster in clusters:
    index += 1
    logging.info("[{0}/{1}] Processing cluster {2}".format(index, len(clusters), ",".join(["#{0}".format(c) for c in cluster])))
    reports = [pyfaf.run.cache_get("fedora-koji-build-funfin-report", i, parser_module=pyfaf.cache.koji_build_funfin_report, failure_allowed=False) for i in cluster]
    # First, do BinaryDupsEvaluation.
    logging.info("  - duplicates evaluation");
    for report in reports:
        for fingerprint in fingerprints:
            fingerprint.add_binary_dups_evaluation(report)

    # Second, do CrossBinaryEvaluation.
    logging.info("  - cross evaluation");
    for pair in itertools.combinations(reports, 2):
        for fingerprint in fingerprints:
            fingerprint.add_cross_binary_evaluation(pair[0], pair[1])

    print_report()
