#!/usr/bin/python
# Copyright (C) 2011 Red Hat, Inc.
# Copyright (C) 2011 Jan Smejda
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
import pyfaf
import subprocess
import logging

# Command line argument processing
cmdline_parser = pyfaf.argparse.ArgumentParser()
cmdline_args = cmdline_parser.parse_args()

# Load database and bugs
db = pyfaf.cache.db_connect()
cursor = db.cursor()

# Load bug ids from local cache
logging.info("Loading RHBZ bug list from db.")
ABRT_BUGS_QUERY = """
SELECT rhbz_bug.id, rhbz_bug.component, rhbz_attachment.id
  FROM rhbz_bug, rhbz_attachment
  WHERE rhbz_attachment.file_name=\"backtrace\"
    AND rhbz_attachment.is_patch=0
    AND rhbz_attachment.is_url=0
    AND rhbz_attachment.is_obsolete=0
    AND rhbz_attachment.bug_id=rhbz_bug.id
"""
cursor.execute(ABRT_BUGS_QUERY)
all_bugs = cursor.fetchall()
logging.info("Found {0} bugs in db.".format(len(all_bugs)))
NONCHECKED_ABRT_BUGS_QUERY = ABRT_BUGS_QUERY + " AND rhbz_bug.id NOT IN (SELECT id FROM rhbz_backtrace_report)"
cursor.execute(NONCHECKED_ABRT_BUGS_QUERY)
check_bugs = cursor.fetchall()
logging.info("Found {0} bugs without reports in db.".format(len(check_bugs)))

# Create helper structures
component_to_bugs = {}
for bug_id, component, attachment_id in all_bugs:
    if component in component_to_bugs:
        component_to_bugs[component].append((bug_id, attachment_id))
    else:
        component_to_bugs[component] = [(bug_id, attachment_id)]

component_to_components = {}
for component in component_to_bugs.keys():
    component_to_components[component] = pyfaf.btserver.all_referenced_components(cursor, component)

component_to_component_intersection = {}
for component1 in component_to_bugs.keys():
    result = set()
    for component2 in component_to_bugs.keys():
        if any(component_to_components[component1] & component_to_components[component2]):
            result.add(component2)
    component_to_component_intersection[component1] = result

# Run the check
for bug_id, component, attachment_id in check_bugs:
    report = pyfaf.cache.rhbz_bug_btserver_report.RhbzBugBtserverReport()
    report.id = bug_id
    # TODO: bt rating, expected_crash_function, reported_crash_function

    cross_check_bugs = []
    for comp in component_to_component_intersection[component]:
        cross_check_bugs += component_to_bugs[comp]

    bug_optimized_backtrace = pyfaf.run.cache_get_path("rhbz-optimized-backtrace",
                                                       bug_id, failure_allowed=True)
    if bug_optimized_backtrace is None:
        continue

    for other_bug_id in cross_check_bugs:
        other_optimized_backtrace = pyfaf.run.cache_get_path("rhbz-optimized-backtrace",
                                                             other_bug_id, failure_allowed=True)
        if other_optimized_backtrace is None:
            continue

        similarity = pyfaf.btserver.backtrace_similarity(bug_optimized_backtrace, other_optimized_backtrace)
        if similarity is None:
            continue

        relation = Relation()
        relation.bug_id = other_bug_id
        relation.levenshtein_distance = similarity[0]
        relation.jacckard_index = similarity[1]
        relation.jaro_winkler_distance = similarity[2]
        report.relations.append(relation)
