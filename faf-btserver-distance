#!/usr/bin/python
# Copyright (C) 2011 Red Hat, Inc.
# Copyright (C) 2011 Jan Smejda
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
import pyfaf
import subprocess
import sys
import re
import os
import tempfile
import logging

def compare((d1, bug1), (d2, bug2)):
    if d1 - 0.1 > d2:
        return 1
    if d1 < d2 - 0.1:
        return -1

    if bug1.status != bug2.status:
        if bug1.status == pyfaf.cache.rhbz_bug.BS_CLOSED:
            return -1
        if bug2.status == pyfaf.cache.rhbz_bug.BS_CLOSED:
            return 1

    if bug1.creation_time > bug2.creation_time:
        return 1
    if bug1.creation_time < bug2.creation_time:
        return -1

    return 0

# Command line argument processing
cmdline_parser = pyfaf.argparse.ArgumentParser()
cmdline_parser.add_argument("component")
cmdline_parser.add_argument("backtrace")
cmdline_args = cmdline_parser.parse_args()

# Optimize the provided backtrace for comparsion.
optimized_backtrace = tempfile.NamedTemporaryFile()
btparser_proc = subprocess.Popen(['btparser', '-o', cmdline_args.backtrace],
                                 stdout=optimized_backtrace)
btparser_proc.communicate()
if btparser_proc.returncode != 0:
    sys.exit(2)
optimized_backtrace.flush()
optimized_backtrace.seek(0)

# Load database and bugs
logging.debug("Connecting to DB.")
db = pyfaf.cache.Database()

logging.info("Getting all referenced components.")
component_deps = pyfaf.btserver.all_referenced_components(db, cmdline_args.component)

# Get bug ids for the components
component_list = ",".join(["\"{0}\"".format(dep) for dep in component_deps])
logging.debug("Found components: {0}.".format(component_list))
db.execute("SELECT id FROM rhbz_bug WHERE component IN ({0})".format(component_list))

logging.info("Loading relevant bugs.")
bugs = []
for row in db.fetchall():
    bug = pyfaf.run.cache_get("rhbz-bug", row[0], failure_allowed=True)
    if bug is None:
        logging.debug("Skipping bug {0}.".format(row[0]))
        continue

    logging.debug("Adding bug {0}.".format(row[0]))
    bugs.append(bug)

db.close()

logging.info("Comparing bugs.")
# Cycle comparing bugs
similarities = []
for bug in bugs:
    # Checking for the other bug's file
    bug_optimized_backtrace = pyfaf.run.cache_get_path("rhbz-optimized-backtrace", bug.id, failure_allowed=True)
    if bug_optimized_backtrace is None:
        logging.debug("No optimized backtrace for bug {0}.".format(bug.id))
        continue

    similarity = pyfaf.btserver.backtrace_similarity(optimized_backtrace.name, bug_optimized_backtrace)
    if similarity is None:
        logging.debug("Unable to get similarity for bug {0}.".format(bug.id))
        continue

    logging.debug("Adding bug {0}.".format(bug.id))
    similarities.append((similarity[0], bug))

logging.debug("Finishing")

ordered = sorted(similarities, cmp=compare)
result = ordered[:5]
all_closed = True

for distance, bug in result:
    if bug.status != pyfaf.cache.rhbz_bug.BS_CLOSED:
        all_closed = False
        break

if all_closed:
    for distance, bug in ordered:
        if bug.status != pyfaf.cache.rhbz_bug.BS_CLOSED:
            result[len(result) - 1] = (distance, bug)
            break

for distance, bug in result:
    line = "{0} {1} {2} {3}".format(bug.id, bug.component, distance, bug.status)
    if bug.status == pyfaf.cache.rhbz_bug.BS_CLOSED:
        line += " {0}".format(bug.resolution)
    print line
