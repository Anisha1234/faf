#!/usr/bin/python
# Copyright (C) 2011 Red Hat, Inc.
# Copyright (C) 2011 Jan Smejda
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
import pyfaf
import btparser
import sys
import re
import os
import logging

def compare((d1, bug1), (d2, bug2)):
    if d1 - 0.1 > d2:
        return 1
    if d1 < d2 - 0.1:
        return -1

    if bug1.status != bug2.status:
        if bug1.status == pyfaf.cache.rhbz_bug.BS_CLOSED:
            return -1
        if bug2.status == pyfaf.cache.rhbz_bug.BS_CLOSED:
            return 1

    if bug1.creation_time > bug2.creation_time:
        return 1
    if bug1.creation_time < bug2.creation_time:
        return -1

    return 0

# Command line argument processing
cmdline_parser = pyfaf.argparse.ArgumentParser()
cmdline_parser.add_argument("component")
cmdline_parser.add_argument("backtrace")
cmdline_args = cmdline_parser.parse_args()

# Optimize the provided backtrace for comparsion.
with open(cmdline_args.backtrace, 'r') as f:
    backtrace = btparser.Backtrace(f.read())
optimized_thread = pyfaf.btserver.get_optimized_thread(backtrace)

# Load database and bugs
logging.debug("Connecting to DB.")
db = pyfaf.cache.Database()

logging.info("Getting all referenced components.")
component_deps = pyfaf.btserver.all_referenced_components(db, cmdline_args.component)

# Get bug ids for the components
component_list = ",".join(["\"{0}\"".format(dep) for dep in component_deps])
logging.debug("Found components: {0}.".format(component_list))
db.execute("SELECT DISTINCT rhbz_bug.id FROM rhbz_attachment, rhbz_bug WHERE file_name = 'backtrace' AND bug_id = rhbz_bug.id AND rhbz_bug.component IN ({0})".format(component_list))

logging.info("Loading relevant bugs.")
bugs = []
for row in db.fetchall():
    bug = pyfaf.run.cache_get("rhbz-bug", row[0], failure_allowed=True)
    if bug is None:
        logging.debug("Skipping bug {0}.".format(row[0]))
        continue

    logging.debug("Adding bug {0}.".format(row[0]))
    bugs.append(bug)

db.close()

logging.info("Reading backtraces.")
bug_threads = []
for bug in bugs:
    # Checking for the other bug's file
    bug_optimized_backtrace = pyfaf.run.cache_get_path("rhbz-optimized-backtrace", bug.id, failure_allowed=True)
    if bug_optimized_backtrace is None:
        logging.debug("No optimized backtrace for bug {0}.".format(bug.id))
        continue

    with open(bug_optimized_backtrace, 'r') as f:
        bug_threads.append((bug, btparser.Thread(f.read(), True)))
        logging.debug("Read optimized backtrace for bug {0}.".format(bug.id))

threads = [thread for (bug, thread) in bug_threads]

logging.info("Comparing bugs.")
distances = pyfaf.btserver.get_distances_to_threads(optimized_thread, threads)

distances_bugs = zip(distances, [bug for (bug, thread) in bug_threads])

logging.debug("Finishing")

ordered = sorted(distances_bugs, cmp=compare)
result = ordered[:5]
all_closed = True

for distance, bug in result:
    if bug.status != pyfaf.cache.rhbz_bug.BS_CLOSED:
        all_closed = False
        break

if all_closed:
    for distance, bug in ordered:
        if bug.status != pyfaf.cache.rhbz_bug.BS_CLOSED:
            result[len(result) - 1] = (distance, bug)
            break

for distance, bug in result:
    line = "{0} {1} {2} {3}".format(bug.id, bug.component, distance, bug.status)
    if bug.status == pyfaf.cache.rhbz_bug.BS_CLOSED:
        line += " {0}".format(bug.resolution)
    print line
